## SRP

### SRP : 단일 책임 원칙 (클래스는 단 한 개의 책임을 가져야 한다)

1. 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야한다

   - 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.

     *'변경의 이유'란 바로 이들 사용자와 이해관계자를 가르킨다

     

2. 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.

   - 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자가 두 명 이상일 수 도 있기 때문에 '사용자'와 '이해관계자'라는 단어를 쓰는 것 보다 해당 변경을 요청하는 한 명 이상의 사람들을 가리키는 집단 = 액터로 표현

     

3. 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

   - 모듈이란? 단순한 정의는 바로 소스 파일이다
     - 하지만 일부 언어와 개발 환경에서는 코드를 소스 파일에 저장하지 않는 경우 모듈은 단수히 함수와 데이터 구조로 구성된 응집된 집합이다
     - '응집된'이라는 단어가 SRP를 암시, 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 응집성이다.

### 징후 1 : 우발적 중복

```예시 코드
calculatePay() //회계팀에서 기능을 정의하며, CFO보고를 위해 사용
reportHours() //메서드는 인사팀에서 기능을 정의하고 사용하며, coo보고를 위해 사용된다.
save() //메서드는 데이터베스 관리자가 기능을 정의하고, CTO보고를 위해 사용한다
```

- 같은 클래스에 작성된 세 가지 메서드가 서로 매우 다른 세 명의 액터를 책임지면 SRP를 위반하는 것이다.
- 단일 클래스에 세 액터가 서로 결합되어 버려서 CFO팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.

### 징후2 : 병합

- 병합에는 항상 위험이 뒤따르게 된다
- 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 높다

### 해결책

- 메서드를 각기 다른 클래스로 이동시키는 방식이다

1. 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다 -70p
   - 데이터 클래스를 다른 클래스들이 공유하도록 하여 서로의 존재를 모르게 하여 '우연한 중복'을 피할 수 있다
2. 퍼사드 패턴 -p.70
   - 1번은 여러 클래스를 인스턴스화하고 추적해야 한다는 단점이 있다. 이러한 난관에서 빠져나올 때 흔히 쓰는 기법이다
   - Facecade클래스는 코드가 거의 없고 데이터 클래스가 아닌 다른 클래스들의 객체를 생성하고, 요청된 메서드를 가지는 객채로 위임하는 역할을 한다
3. 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다 - 71p
   - 가장 중요한 메서드는 기존의 Emplyee클래스에 그대로 유지하되, Employee클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있다. 

### 결론

- 단일 책임 원칙은 메서들와 클래스 수준의 원칙이다.
- 컴포넌트 수준에서는 공통 폐쇄 원칙이 된다.
- 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.



### 주의!!!

* 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽다
* 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용되는 원칙이다
