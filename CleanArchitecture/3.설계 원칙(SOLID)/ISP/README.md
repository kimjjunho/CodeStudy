## ISP

### ISP : 인터페이스 분리 원칙

```인터페이스 분리 원칙
User1 ->> OPS + op1(op1만 사용)
User2 ->> OPS + op2(op2만 사용)
User3 ->> OPS + op3(op3만 사용)
```

*OPS가 정적 타입 언어로 작성된 클래스라면

- User1에서는 op2와 op3를 전혀 사용하지 않음에도 User1의 소스 코드는 이 두 메서드에 의존하게 된다.
- 이러한 의존성에 의해 OPS 클래스에서 op2의 소스 코드가 변경되면 User1도 다시 컴파일한 후 새로 배포해야 한다.(User1과 관련된 코드는 전혀 변경되지 않았어도)
- 이러한 문제를 오퍼레이션을 인터페이스 단위로 분리하여 해결한 경우

```분리된 오퍼레이션
User1 ->> U10ps + op1 <- OPS + op1 + op2 + op3
User2 ->> U20ps + op2 <- OPS + op1 + op2 + op3
User3 ->> U30ps + op3 <- OPS + op1 + op2 + op3
//U10ps, U20ps, U30ps가 인터페이스이다
```

### ISP와 언어

- 정적 타입 언어는 사용자가 import, use 또는 include와 같은 타입 선언문을 사용하도록 강제한다.
- 이처럼 소스 코드에 포함된 선언문으로 인해 소스 코드 의존성이 발생하 의존성이 발생하고 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.

### ISP와 아키텍처

- 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 소스 코드의 재컴파일과 재배포를 강제하게 되기 때문에 해로운 일이다.

```문제가 있는 아키텍처
System S ->> Framework F ->> Database D
```

- 아키텍트는 F라는 프레임워크를 시스템에 도입하기를 원한다. -> 그리고 F프레임워크 개발자는 특정한 D데이터베이스를 반드시 사용하도록 만들었다고 가정하면 S는 F에 의존하며, F는 D에 의존하게 된다
- F에서는 불필요한 기능, 따라서 S와는 전혀 관계없는 기능이 D에 포함된다고 가정하면 그 기능 때문에 D내부가 변경되면, F를 재배포해야 할 수도 있고, 따라서 S까지 재배포해야 할지 모른다.
- 가장 심각한 문제는 D내부가 변경되면 F와 S에 영향을 줄 수 있다.(심지어 S와 F의 불필요한 기능일 수도 있다)

### 결론

- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다는 사실이다

