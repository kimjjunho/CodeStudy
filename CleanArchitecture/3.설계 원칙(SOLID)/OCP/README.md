## OCP

### 개방-폐쇄 원칙(소프트웨어 개체는 확장에는 여려 있어야 하고, 변경에는 닫혀 있어야 한다)

- 소프트웨어 객체의 행위는 확장(변경)할 수 있어야 하지만, 이때 개체를 변경해서는 안된다

### 사고 실험

- 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(SRP), 이들 요소 사이의 의존서을 체계화함으로써(DIR) 변경량을 최소화 할 수 있다

- 책임을 분리화 하고 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다. -p.75

- 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.

- 만약 A -> B라면 A클래스에서는 B클래스를 호출하지만 B클래스에서는 A클래스를 전형 호출하지 않음을 뜻함

  *A컴포넌트에서 발생한 변경으로부터 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야 한다

  *화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다

- 모든 컴포넌트의 관계는 단방향으로 이루어진다

  *컴포넌트란? 여러 개의 프로그램 함수들을 모아 하나의 특정한 기능을 수행할 수 있도록 구성한 작은 기능적 단위를 말한다, 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈을 뜻한다, 독립적인 단위 모듈이다

- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.

### 방향성 제어

- 인터페이스(위치)는 의존성을 역전시키기 위해 사용되기도 한다

### 정보 은닉

- 인터페이스는 방향성 제어와는 다른 목적을 가진다.

- 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재하기도 한다

- 인터페이스가 없다면 추이 종속성을 가질 수도 있게 된다

  *추이 종속성이란 클래스 A가 클래스 B를 의존하고, 다시 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 된다.

  *추이 종속성을 가지게 되면, '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.

- 예를 들어 Controller에서 발생한 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만, 반대로 Interactor에서 발생한 변경으로 부터 Controller도 보호되기를 바란다. 이를 위해 Interactor내부를 은닉한다

  *정보은닉 : 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것이다.

### 결론

- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.

- 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어 지도록 해야 한다.

  *저수준 컴포넌트는 고수준 컴포넌트에 의존
