# 클린 아키텍처

### 설계

- 저수준의 구조 또는 결정사항 등을 의미할 때가 많다 -p.6

### 아키텍처

- 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용된다 -p.6

​	*아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미하다. 아무런 차이가 없다 -p.6

​	*아키텍트란? 아키텍처 및 시스템 설계하기 위하여 구성하는 각각의 컴포넌트를 선택하고 그에 따른 표준을 정립하여 독립적인 컴포넌트 간의 관계를 정의 함으로써 유기적인 하나의 시스템을 설계하는 사람을 뜻한다

### 행위 p.16

- 소프트웨어의 첫 번째 가치

- 프로그래머는 이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다.

- 이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다

  *이해관계자 : 기업,행정,NPO 등과 관련하여 직접·간접적으로 이해관계를 가지는 사람

  *소프트웨어 개발자는 **행위와 구조** 두 가치를 모두 반드시 높게 유지해야 하는 책임을 진다

### 아키텍처

- 소프트웨어는 변경하기 쉬워야 한다.

- 변경사항을 간단하고 쉽게 적용할 수 있어야 한다.

- 변경사항을 적용하는 데 드는 어려움은 변경되는 **범위**에 비례해야 하며, 변경사항의 **형태**와는 관련이 없어야 한다

- 아키텍처는 형태에 독립적이여야 하고, 그럴수록 더 실용적이다.

  *소프트웨어 개발 비용의 증가를 결정짓는 주된 요인은 변경사항의 범위와 형태의 차이에 있다

### 소프트웨어 아키텍처의 목표

- 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다. -p.7

  좋은 설계 : 비용이 낮고 수명이 다할 때까지 낮게 유지할 수 있음

  나쁜 설계 : 새로운 기능을 출시할 때마다 비용이 증가한다

### 패러다임

*패러다임이란? 사물에 대한 이론적인 틀이나 체계. 

그 언어가 가진 목적에 부합하게 사용할 수 있는지, 어떻게 하면 해당 언어처럼 사고하는지와 관련된 것이다. 

1. **구조적 프로그래밍** p.26
   - 최초로 적용된 패러다임(최초로 만들어진 패러다임은 아님)
   - 무분별한 goto 문장을 if/then/else, do/while/until과 같이 더 익숙한 구조로 대체했다.
   - 제어흐름의 직접적인 전환에 대해 규칙을 부과한다
2. **객체 지향 프로그래밍** p.26
   - 두 번째로 도입된 패러다임(구조적 프로그래밍보다 2년 먼저 나왔다)
   - 제어흐름의 간접적인 전환에 대한 규칙을 부과한다
3. **함수형 프로그래밍** p.27
   - 도입은 늦었지만 세 패러다임 중 가장 먼저 만들어짐
   - 할당문에 대해 규칙을 부과한다(변수 할당에 부과되는 규율)
4. **생각** p.27 ~ p.28
   - 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다
   - 최소한 부정적인 의도를 가진 패러다임은 이 3가지가 전부일 것이다(수십년 동안 새로 등장한 패러다임이 전혀 없다)
   - 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목해야 한다.

### 구조적 프로그래밍

- goto문의 '좋은' 사용 방식은 if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견 -p.31
- 이러한 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다. -p.32
- 모든 프로그램을 순차, 분기, 반복이라는 세 가지 구조만으로 표현할 수 있다. -p.32
- 모듈을 증명 가능하게 하는 제어구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실을 발견(구조적 프로그래밍의 탄생) -p.32

### 객체 지향 언어

*00은 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 휙득할 수 있는 능력이다

- 좋은 아키텍처 만드는 일은 객체 지향 00설계 원칙을 이해하고 응용하는 데서 출발한다.

- 00가 캡슐화, 상속, 다형성 이 세 가지 개념을 적절하게 조합한 것이거나, 00언어는 최소한 세 가지 요소를 반드시 지원해야 한다고 말하기도 한다.

  **캡슐화** -p.38

  - 00언어는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공한다
  - 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다
  - 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다

  **상속** -p.41

  - 상속이란? 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다
  - 00언어가 완전히 새로운 개념을 만든 것은 아니지만 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있다.

  **다형성** -p.44

  *다형성이란? 하나의 객체에 여러 가지 타입을 대입할 수 있는 것

  - 00언어는 다형성을 좀 더 쉽고 안전하고 더욱 편리하게 사용할 수 있게 해준다
  - 00언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대한 방향을 결정할 수 있는 절대적인 권한을 갖는다.(소스 코드 의존성을 원하는 방향으로 설정할 수 있다)

### 함수형 프로그래밍

- 프로그래밍 그 자체보다 앞서 등장했다(이 패러다임에서 핵심이 되는 기반은 람다 계산법으로 1930년대 발명되었다)
- 아키텍트가 변수의 가변성을 염려하는 이유? 경합조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문이다 -p.56
- 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다 -p.56

### 주의할 점

- 코드를 정리하면서 짜는것 보다 빠르게 기능을 구현 하려고만 하면 코드는 엉망진창이 되고 생산성은 0을 향해 수렴하기 시작한다 p.12
- 아키텍처가 지닌 속성을 알고 품질이 좋은 시스템을 만들어야 한다 p.14
- 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다. -p.36
- 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. -p.60



---

# Clean Architecture in Android

- 복잡도가 높은 애플리케이션을 개발할때 유지 보수하기 쉽고 고품질의 코드를 작성할 수 있도록 구조화해야 한다.

### 4가지 계층

1. **Entities**
   - 비즈니스 규칙을 캡슐화 함. 앤티티는 메서드를 갖는 객체일 수도 있지만 데이터 구조와 함수의 집합일 수도 있다. 가장 일반적이면서 고수준의 규칙을 캡슐화하게 된다. 외부가 변경되더라도 이러한 규칙이 변경될 가능성이 적다.
2. **Use cases**
   - 애플리케이션의 고유 규칙을 캡슐화하며 엔티티로부터의 데이터 흐름을 조합한다. 유스케이스 계층의 변경이 엔티티에 영향을 줘서는 안 되며 데이터베이스, 공통 프레임워크 및 UI에 대한 변경으로부터 격리된다.
3. **Interface Adapters(Presenters)**
   - 인터페이스 어댑터는 Entitiy 및 UseCase의 편리한 형식에서 데이터베이스 및 웹에 적용할 수 있는 형식으로 변환한다. 이 계층에는 MVP 패턴의 Presenter, MVVM 패턴의 ViewModel가 포함된다. 즉, 순수한 비즈니스 로직만을 담당하는 역할을 한다
4. **Frameworks & Drivers(Web, DB)**
   - 프레임워크와 드라이버는 상세한 정보들을 두게 된다. 웹 프레임워크, 데이터베이스, UI, HTTP client 등으로 구성된 가장 바깥쪽 계층이다.

### 주의점

- 클린 아키텍처가 동작히 위해서는 의존성 규칙을 잘 지켜줘야 한다. 각각의 클래스는 한가지 역할만 수행하고, 서로 의존 관계를 어떻게 할지 규칙이 정해져 있고 이를 지켜줘야 한다.
- 의존성 규칙은 반드시 외부 -> 내부 / 저수준 정책 -> 고수준 정책으로 행해야 한다.
- 내부로 갈수록 의존성이 낮아짐
- 예를 들어 안드로이드에서 ViewModel은 DB나 Web과 같은 세부적인 사항에 의존하지 않아야 한다.
- 이를 통해 비지니스 록직(고수준 정책, ViewModel)은 세부 사항(저수준 정책)의 변경에 영향받지 않도록 할 수 있다

### 이점

- 새로운 기능을 빠르게 적용할 수 있다
- 집중화된 클래스에 따른 프로젝트 유지 관리에 용이하다
- 패키지 구조 탐색이 쉬워진다
- 테스트 코드 작성에 용이하다

### 안드로이드 일반적인 계층

- Presentaion, Domain, Data 총 3개의 계층으로 나눠지게 된다. Presentation -> Domain, Data -> Domain 방향으로 의존성을 갖고 있다.

1. **Presentation**
   - 화면과 입력에 대한 UI와 관련된 부분을 담당한다
   - Domain 계층에 대한 의존성을 가지고 있다
2. **Domain**
   - UseCase와 Model을 포함한다, Repository 인터페이스도 포함되어 있다.
   - UseCase : 각 개별 기능 또는 비지니스 논리 단위
   - Presentation, Data 계층에 대한 의존성을 가지지 않고 독립적으로 분리되어 있다.
   - 안드로이드의 의존성을 갖지 않고 java 및 kotlin 코드로만 구성하며 다른 애플리케이션에서도 사용할 수 있다
3. **Data**
   - Domain 계층에 의존성을 가지고 있다. Domain계층의 Repository 구현체를 포함하고 있으며, 데이터베이스, 서버와의 통신도 Data 게층에서 이루어진다. 또한 mapper 클래스를 통해 Data 계층의 모델을 Domain 계층의 모델로 변환해주는 역할도 한다

이처럼 구조를 작성하게 되면 예를 들어서 데이터베이스는 Data 계층에서만 존재하기 때문에 Realm에서 Room으로 데이터베이스를 변경한다고 하면 Data 계층의 Repository 구현체만 Roomdmfh 변경해 주면 된다.

https://leveloper.tistory.com/205
