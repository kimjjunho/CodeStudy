# 클린 아키텍처

### 설계

- 저수준의 구조 또는 결정사항 등을 의미할 때가 많다 -p.6

### 아키텍처

- 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용된다 -p.6

​	*아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미하다. 아무런 차이가 없다 -p.6

​	*아키텍트란? 아키텍처 및 시스템 설계하기 위하여 구성하는 각각의 컴포넌트를 선택하고 그에 따른 표준을 정립하여 독립적인 컴포넌트 간의 관계를 정의 함으로써 유기적인 하나의 시스템을 설계하는 사람을 뜻한다

### 행위 p.16

- 소프트웨어의 첫 번째 가치

- 프로그래머는 이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다.

- 이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다

  *이해관계자 : 기업,행정,NPO 등과 관련하여 직접·간접적으로 이해관계를 가지는 사람

  *소프트웨어 개발자는 **행위와 구조** 두 가치를 모두 반드시 높게 유지해야 하는 책임을 진다

### 아키텍처

- 소프트웨어는 변경하기 쉬워야 한다.

- 변경사항을 간단하고 쉽게 적용할 수 있어야 한다.

- 변경사항을 적용하는 데 드는 어려움은 변경되는 **범위**에 비례해야 하며, 변경사항의 **형태**와는 관련이 없어야 한다

- 아키텍처는 형태에 독립적이여야 하고, 그럴수록 더 실용적이다.

  *소프트웨어 개발 비용의 증가를 결정짓는 주된 요인은 변경사항의 범위와 형태의 차이에 있다

### 소프트웨어 아키텍처의 목표

- 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다. -p.7

  좋은 설계 : 비용이 낮고 수명이 다할 때까지 낮게 유지할 수 있음

  나쁜 설계 : 새로운 기능을 출시할 때마다 비용이 증가한다

### 패러다임

*패러다임이란? 사물에 대한 이론적인 틀이나 체계. 

그 언어가 가진 목적에 부합하게 사용할 수 있는지, 어떻게 하면 해당 언어처럼 사고하는지와 관련된 것이다. 

1. **구조적 프로그래밍** p.26
   - 최초로 적용된 패러다임(최초로 만들어진 패러다임은 아님)
   - 무분별한 goto 문장을 if/then/else, do/while/until과 같이 더 익숙한 구조로 대체했다.
   - 제어흐름의 직접적인 전환에 대해 규칙을 부과한다
2. **객체 지향 프로그래밍** p.26
   - 두 번째로 도입된 패러다임(구조적 프로그래밍보다 2년 먼저 나왔다)
   - 제어흐름의 간접적인 전환에 대한 규칙을 부과한다
3. **함수형 프로그래밍** p.27
   - 도입은 늦었지만 세 패러다임 중 가장 먼저 만들어짐
   - 할당문에 대해 규칙을 부과한다(변수 할당에 부과되는 규율)
4. **생각** p.27 ~ p.28
   - 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다
   - 최소한 부정적인 의도를 가진 패러다임은 이 3가지가 전부일 것이다(수십년 동안 새로 등장한 패러다임이 전혀 없다)
   - 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목해야 한다.

### 구조적 프로그래밍

- goto문의 '좋은' 사용 방식은 if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견 -p.31
- 이러한 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다. -p.32
- 모든 프로그램을 순차, 분기, 반복이라는 세 가지 구조만으로 표현할 수 있다. -p.32
- 모듈을 증명 가능하게 하는 제어구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실을 발견(구조적 프로그래밍의 탄생) -p.32

### 객체 지향 언어

*00은 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 휙득할 수 있는 능력이다

- 좋은 아키텍처 만드는 일은 객체 지향 00설계 원칙을 이해하고 응용하는 데서 출발한다.

- 00가 캡슐화, 상속, 다형성 이 세 가지 개념을 적절하게 조합한 것이거나, 00언어는 최소한 세 가지 요소를 반드시 지원해야 한다고 말하기도 한다.

  **캡슐화** -p.38

  - 00언어는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공한다
  - 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다
  - 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다

  **상속** -p.41

  - 상속이란? 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다
  - 00언어가 완전히 새로운 개념을 만든 것은 아니지만 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있다.

  **다형성** -p.44

  *다형성이란? 하나의 객체에 여러 가지 타입을 대입할 수 있는 것

  - 00언어는 다형성을 좀 더 쉽고 안전하고 더욱 편리하게 사용할 수 있게 해준다
  - 00언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대한 방향을 결정할 수 있는 절대적인 권한을 갖는다.(소스 코드 의존성을 원하는 방향으로 설정할 수 있다)

### 함수형 프로그래밍

- 프로그래밍 그 자체보다 앞서 등장했다(이 패러다임에서 핵심이 되는 기반은 람다 계산법으로 1930년대 발명되었다)
- 아키텍트가 변수의 가변성을 염려하는 이유? 경합조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문이다 -p.56
- 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다 -p.56







### 주의할 점

- 코드를 정리하면서 짜는것 보다 빠르게 기능을 구현 하려고만 하면 코드는 엉망진창이 되고 생산성은 0을 향해 수렴하기 시작한다 p.12
- 아키텍처가 지닌 속성을 알고 품질이 좋은 시스템을 만들어야 한다 p.14
- 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다. -p.36
- 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. -p.60
